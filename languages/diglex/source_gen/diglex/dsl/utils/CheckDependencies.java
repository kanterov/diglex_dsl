package diglex.dsl.utils;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class CheckDependencies {
  public CheckDependencies() {
  }

  public static Iterable<SNode> GetNotConnectedTemplates(Set<SNode> templates, SNode target) {

    Set<SNode> connectedTemplates = SetSequence.fromSet(new HashSet<SNode>());
    SetSequence.fromSet(connectedTemplates).addElement(target);

    for (SNode template : SetSequence.fromSet(templates)) {
      Logger.getLogger("wtf").debug(SPropertyOperations.getString(template, "name"));
      IsTemplateConnected(template, connectedTemplates);
    }

    return SetSequence.fromSet(templates).subtract(SetSequence.fromSet(connectedTemplates));
  }

  private static boolean IsMatchCaseItemConnected(SNode matchCaseItem, Set<SNode> connectedTemplates) {

    boolean isConnected = false;

    if (SNodeOperations.isInstanceOf(matchCaseItem, "diglex.dsl.structure.TemplateReference")) {
      SNode templateReference = SNodeOperations.as(matchCaseItem, "diglex.dsl.structure.TemplateReference");
      SNode template = SLinkOperations.getTarget(templateReference, "TemplateReference", false);

      if (IsTemplateConnected(template, connectedTemplates)) {
        isConnected = true;
      }
    }

    if (SNodeOperations.isInstanceOf(matchCaseItem, "diglex.dsl.structure.DistantContext")) {
      SNode distantContext = SNodeOperations.as(matchCaseItem, "diglex.dsl.structure.DistantContext");

      for (SNode condition : ListSequence.fromList(SLinkOperations.getTargets(distantContext, "Conditions", true))) {
        SNode template = SLinkOperations.getTarget(condition, "TemplateReference", false);

        if (IsTemplateConnected(template, connectedTemplates)) {
          isConnected = true;
          break;
        }
      }
    }

    return isConnected;
  }

  public static boolean IsTemplateConnected(SNode source, Set<SNode> connectedTemplates) {
    if (SetSequence.fromSet(connectedTemplates).contains(source)) {
      return true;
    }

    boolean isConnected = false;

    for (SNode matchCase : ListSequence.fromList(SLinkOperations.getTargets(source, "MatchCases", true))) {
      if (isConnected) {
        break;
      }

      for (SNode item : ListSequence.fromList(SLinkOperations.getTargets(matchCase, "Items", true))) {
        if (IsMatchCaseItemConnected(item, connectedTemplates)) {
          isConnected = true;
          break;
        }
      }

      if (!(isConnected) && (SLinkOperations.getTarget(matchCase, "Postcondition", true) != null)) {
        for (SNode item : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(matchCase, "Postcondition", true), "Items", true))) {
          if (IsMatchCaseItemConnected(item, connectedTemplates)) {
            isConnected = true;
            break;
          }
        }
      }

      if (!(isConnected) && (SLinkOperations.getTarget(matchCase, "Precondition", true) != null)) {
        for (SNode item : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(matchCase, "Precondition", true), "Items", true))) {
          if (IsMatchCaseItemConnected(item, connectedTemplates)) {
            isConnected = true;
            break;
          }
        }
      }
    }

    if (isConnected) {
      SetSequence.fromSet(connectedTemplates).addElement(source);
    }

    return isConnected;
  }
}
